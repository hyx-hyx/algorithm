## 1001[题目链接](https://vjudge.net/problem/HDU-7025)
题意：给定数x，求包含x的区间和为素数的最小区间长度
分析：
显然 r > 0,r ≥ l，如果 l ≤ 0，此时 [l,r] 区间和 = [−l + 1,r] 的区间和，且 r ≥ −l + 1 > 0。
故对于任意一个区间，都可以找到一个对应的 r ≥ l > 0 的区间与之对应，区间和相同。对于下式：$\sum_{i=l}^ri=\frac{(l+r)(r-l+1)}{2}$

当 l > 0 时，若 r − l ≥ 2，则$\frac{l+r}{2}$和$\frac{r-l+1}{2}$之中必有一个是大于 1 的整数。区间和必然能被拆分成两个因数的乘积。所以这样的满足和为素数的区间长度必然不长于 2。

预处理出比 [2,2 × 10 7 ] 略大范围内的质数，埃氏筛或者线筛均可。

如果 x ≤ 0，则候选答案为：
* 最小的 y(y ≥ 1 − x)，满足 y 是质数，区间为 [−y + 1,y]。
* 最小的 z(z ≥ 2 − x)，满足 2z − 1 是质数，区间为 [−z + 2,z]。

如果 x > 0，则候选答案为：
*  [x,x]。
*  [x,x + 1]。
*  [x − 1,x]。
*  最小的 y(y ≥ x)，满足 y 是质数，区间为 [−y + 1,y]。
*  最小的 z(z ≥ x)，满足 2z − 1 是质数，区间为 [−z + 2,z]。
二分查找即可，时间复杂度为 O(T log(|x|) + |x|)。
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<cstdio>
#include<iostream>
#include<vector>
#include<cstring>
#include<string>
#include<queue>
#define maxn 20000010
using namespace std;
int prime[maxn];
int visit[maxn];
void Prime() {
    memset(visit, 0,sizeof(visit));
    memset(prime, 0,sizeof(prime));
    visit[0] = 1;
    visit[1] = 1;
    for (int i = 2; i <= maxn; i++) {
        if (!visit[i]) {
            prime[++prime[0]] = i;
        }
        for (int j = 1; j <= prime[0] && i * prime[j] <= maxn; j++) {
            visit[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                break;
            }
        }
    }
}
int main()
{
	int t;
    Prime();
	scanf("%d", &t);
	while (t--)
	{
		int x;
		scanf("%d", &x);
        int minindex = maxn;
		if (x <= 0)
		{
            int i;
            for (i = 1 - x; visit[i]; ++i);
            minindex = min(minindex, 2 * i);
            for (i = 2 - x; visit[2 * i - 1]; ++i);
            minindex = min(minindex, 2*i-1);
            printf("%d\n", minindex);
		}
        else
        {
            int i = 0;
            if (!visit[x])
                printf("1\n");
            else
            {
                if (!visit[2 * x + 1] || !visit[2 * x - 1])
                    printf("2\n");
                else
                {
                    for (i = x; visit[i]; ++i);
                    minindex = min(minindex, 2*i);
                    for (i = x; visit[2 * i - 1]; ++i);
                    minindex = min(minindex, 2 * i - 1);
                    printf("%d\n", minindex);
                }
            }
        }
	}
	return 0;
}

```
## 1005 [题目链接](https://vjudge.net/problem/HDU-7029)
```cpp

```